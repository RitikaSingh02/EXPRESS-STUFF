//response headers while using django
HTTP/1.1 400 Bad Request
Date: Sun, 08 Nov 2020 16:37:44 GMT
Server: WSGIServer/0.2 CPython/3.7.9
Content-Type: application/json
X-Frame-Options: SAMEORIGIN//the browser content canot be framed in <frame> ,<iframe>,<object> tags.
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: http://localhost:4007
Vary: Origin, Cookie
Content-Length: 23

//WSGI
::The Web Server Gateway Interface is a simple calling convention for web servers to forward requests
 to web applications or frameworks written in the Python programming language.
 The current version of WSGI, version 1.0.1,
//Why You Need WSGI
::WSGI servers are designed to handle many requests concurrently.
Frameworks are not made to process thousands of requests and determine how to best route them from the server. WSGI speeds up
Python web application development because you only need to know basic things about WSGI.

::mod_wsgi vs. mod_python:
    mod_wsgi is a little faster (internally there's more C, less Python)
    mod_wsgi processes can be isolated from Apache, which improves security/stability with lower memory use[1]
    mod_python gives you access to some of Apache's internals

::WSGI in general:
    lots of reusable middleware (authentication/authorisation, session stuff, caching, filtering)
    ease of deployment on non-Apache webservers either via native WSGI support or flup

//WSGI BEST EXPLANATION:https://www.youtube.com/watch?v=UklcIDgHtwQ&ab_channel=DjangoLessons

//XFRAME-HEADERS:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
::X-Frame-Options (XFO), is an HTTP response header, also referred to as an HTTP security header,
::This header tells your browser how to behave when handling your site's content. The main reason for its inception was to provide clickjacking protection by not allowing rendering of a page in a frame.
::This can include rendering of a page in a <frame>, <iframe>, or <object>.

=>Django itself is synchronous.(async support is only for >3.0 ver)
each HTTP request will be handled completely synchronously.
However you have extensions like django-channels ( https://github.com/django/channels ) , which are asynchronous and are intended for web sockets / etc.

=>Celery is an asynchronous task queue based on distributed message passing.
 Task queues are used as a strategy to distribute the workload between threads/machines.
//Django has support for writing asynchronous (“async”) views, along with an entirely async-enabled request stack if you are running under ASGI. Async views will still work under WSGI, but with performance penalties
, and without the ability to have efficient long-running requests.

//response headers while using EXPRESS
Content-Length: 45
Content-Type: application/json; charset=utf-8
Date: Sun, 08 Nov 2020 17:12:08 GMT
ETag: W/"2d-RcdgY6Ke32/Y+2ofjx54amAKsyQ"
X-Powered-By: Express

::ETAGS ARE GENERATED BY THE SERVERS (OBVIOUSLY ) SO THEY ARE NOT IN CONTROL OF USER 
SO THERE CAN BE A PRIVACY GLITCH..
::BESIDE THAT IF SERVERS ARE GOING TO CHANGE THEN DIFF ETAGS WILL BE GENERATED FOR
THE SAME Request SO OUR FEASIBILITY OF CACHING IS LOST!!
:::!!!!!ETAGS ARE NOT EASILY DELETED BY THE USER WHEREAS COOKIES ARE HENCE THE CLIENT CAN 
BE EASILY TRACKED WHICH ISNOT SAFE SO ITS A GD PRACTICE TO REMOVE ETAGS
//ETAG-PROS-CONS:: https://www.youtube.com/watch?v=TgZnpp5wJWU&ab_channel=HusseinNasser